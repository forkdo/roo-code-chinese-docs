---
description: 了解 switch_mode 如何在 Roo Code 中实现 Code、Architect、Ask 和 Debug 模式之间的无缝切换，以处理专门的任务。
keywords:
  - switch_mode
  - Roo Code 工具
  - 模式切换
  - 操作模式
  - Code 模式
  - Architect 模式
  - Debug 模式
  - Ask 模式
  - 任务转换
  - VS Code AI
image: /img/social-share.jpg
---

# switch_mode

`switch_mode` 工具使 Roo 能够在不同的操作模式之间切换，每种模式都具备处理特定类型任务的专门能力。这允许在当前任务需要不同专业知识时，在 Code、Architect、Ask 或 Debug 模式之间无缝转换。

---

## 参数

该工具接受以下参数：

- `mode_slug`（必需）：要切换到的模式的 slug（例如 "code"、"ask"、"architect"）
- `reason`（可选）：切换模式的原因，为用户提供上下文

---

## 功能说明

此工具在当前任务更适合由另一种模式的能力处理时，请求模式切换。它在保持上下文的同时，将 Roo 的焦点和可用工具集调整为匹配新模式任务阶段的要求。

---

## 使用场景

- 从信息收集过渡到代码实现时
- 从编码转向架构或设计时
- 当前任务需要另一种模式才具备的能力时
- 复杂项目的特定阶段需要专业知识时

---

## 主要特性

- 在模式转换期间保持上下文连续性
- 为模式切换建议提供清晰的理由
- 所有模式切换都需要用户明确批准
- 强制执行每个模式特定的工具组限制
- 根据所选模式无缝调整工具可用性
- 支持标准模式和自定义模式
- 在 UI 中显示模式切换和原因
- 使用 XML 样式格式指定参数
- 处理特定于某些模式的文件类型限制

---

## 限制

- 无法切换到系统中不存在的模式
- 每次模式转换都需要用户明确批准
- 在切换完成之前无法使用特定于模式的工具
- 模式切换后应用 500ms 延迟以允许更改生效
- 某些模式有文件类型限制（例如 Architect 模式只能编辑 markdown 文件）
- 模式保留以恢复仅适用于 `new_task` 功能，不适用于一般模式切换

---

## 工作原理

当调用 `switch_mode` 工具时，它遵循以下过程：

1. **请求验证**：
   - 验证请求的模式在系统中存在
   - 检查 `mode_slug` 参数是否已提供且有效
   - 验证用户尚未处于请求的模式中
   - 确保提供的 `reason` 参数（如果提供）格式正确

2. **模式转换准备**：
   - 将模式更改请求与提供的原因打包
   - 向用户显示更改请求以供批准

3. **模式激活（用户批准后）**：
   - 更新 UI 以反映新模式
   - 根据模式的工具组配置调整可用工具
   - 应用模式特定的提示和行为
   - 应用 500ms 延迟以允许更改生效，然后执行下一个工具
   - 强制执行特定于模式的文件限制

4. **继续**：
   - 使用新模式的功能继续任务
   - 保留来自先前交互的相关上下文

---

## 工具组关联

`switch_mode` 工具属于 "modes" 工具组，但也包含在 "always available" 工具列表中。这意味着：

- 它可以在任何模式中使用，不受模式配置的工具组限制
- 它与其他核心工具（如 `ask_followup_question` 和 `attempt_completion`）一起可用
- 它允许在工作流程中的任何时候进行模式转换，当任务需求发生变化时

---

## 模式结构

系统中的每个模式都有特定的结构：

- `slug`：模式的唯一标识符（例如 "code"、"ask"）
- `name`：模式的显示名称（例如 "Code"、"Ask"）
- `roleDefinition`：模式的专门角色和能力
- `customInstructions`：可选的模式特定指令，指导行为
- `groups`：模式可用的工具组，可选限制

---

## 模式能力

核心模式提供这些专门能力：

- **Code 模式**：专注于编码任务，完全访问代码编辑工具
- **Architect 模式**：专门用于系统设计和架构规划，仅限编辑 markdown 文件
- **Ask 模式**：优化用于回答问题和提供信息
- **Debug 模式**：配备用于系统性问题诊断和解决

---

## 自定义模式

除了核心模式外，系统还支持自定义项目特定模式：

- 可以定义具有特定工具组的自定义模式
- 它们可以指定自定义角色定义和指令
- 系统首先检查自定义模式，然后回退到核心模式
- 自定义模式定义优先于具有相同 slug 的核心模式

---

## 文件限制

不同的模式可能有特定的文件类型限制：

- **Architect 模式**：只能编辑匹配 `.md` 扩展名的文件
- 尝试编辑受限制的文件类型会导致 `FileRestrictionError`
- 这些限制有助于在模式之间强制执行适当的职责分离

---

## 使用示例

- 当讨论新功能时，Roo 从 Ask 模式切换到 Architect 模式以帮助设计系统结构。
- 在 Architect 模式完成架构规划后，Roo 切换到 Code 模式以实现设计的功能。
- 在开发过程中遇到错误时，Roo 从 Code 模式切换到 Debug 模式进行系统性故障排除。

---

## 使用示例

切换到 Code 模式进行实现：
```
<switch_mode>
<mode_slug>code</mode_slug>
<reason>需要根据我们讨论的架构实现登录功能</reason>
</switch_mode>
```

切换到 Architect 模式进行设计：
```
<switch_mode>
<mode_slug>architect</mode_slug>
<reason>需要在实现之前设计系统架构</reason>
</switch_mode>
```

切换到 Debug 模式进行故障排除：
```
<switch_mode>
<mode_slug>debug</mode_slug>
<reason>需要系统性地诊断身份验证错误</reason>
</switch_mode>
```

切换到 Ask 模式获取信息：
```
<switch_mode>
<mode_slug>ask</mode_slug>
<reason>需要回答关于已实现功能的问题</reason>
</switch_mode>
```