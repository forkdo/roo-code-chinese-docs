---
description: 了解 attempt_completion 工具如何在 Roo Code 中标记任务完成、展示结果并支持迭代优化。
keywords:
  - attempt_completion
  - 任务完成
  - 结果展示
  - Roo Code 工具
  - 用户反馈
  - 任务摘要
image: /img/social-share.jpg
---

# attempt_completion

`attempt_completion` 工具用于标记 Roo 认为任务已完成，并向用户展示结果。它提供完成内容的摘要，可选地包含一个用于演示结果的命令，并通过用户反馈支持持续的迭代优化。

---

## 参数

该工具接受以下参数：

- `result`（必需）：最终结果描述，总结完成的内容
- `command`（可选）：用于演示结果的 CLI 命令

---

## 功能说明

此工具通过展示当前任务完成的最终摘要来标记任务结束。它向用户和系统发出明确信号，表明当前任务已完成。当提供命令时，它还可以通过实时执行来演示结果。

---

## 使用场景

- 当 Roo 认为用户任务已完成时
- 当总结已进行的更改或改进时
- 当通过命令执行演示当前结果时
- 当为用户提供解决方案反馈的检查点时
- 当从工作的一个阶段过渡到潜在的优化阶段时

---

## 主要特性

- 提供明确信号，表明 Roo 认为任务已完成
- 以简洁的消息总结完成内容
- 可选地通过命令执行演示结果
- 支持用户反馈以进行进一步优化
- 在特殊 UI 格式中显示结果，区别于常规消息
- 捕获任务完成遥测数据用于系统分析
- 通过提供检查点维持结构化的对话流程
- 支持大型工作流中的子任务完成
- 确保用户获得清晰的完成内容摘要
- 作为"始终可用"工具组的一部分，在所有模式中均可使用

---

## 局限性

- 仅在确认之前工具使用成功后才应使用（指导原则，非强制执行）
- 仅限使用单个命令演示结果
- 无法提供多个命令选项
- 命令需要用户批准后才能执行
- 仅能通过 CLI 命令展示可演示的结果
- 不能用于部分任务完成或进度更新
- 结果格式化通过内部处理移除 XML 结束标签

---

## 工作原理

当调用 `attempt_completion` 工具时，它遵循以下流程：

1. **安全性考虑**（指导原则，非强制执行）：
   - AI 被指示确认之前工具使用已成功
   - 这是最佳实践，而非编程强制机制

2. **结果展示**：
   - 在特殊"completion_result" UI 格式中向用户显示完成消息
   - 使用 `removeClosingTag` 函数从结果文本中移除 XML 结束标签
   - 以区别于常规消息的视觉形式展示结果

3. **命令执行**（如提供）：
   - 在执行命令前请求用户批准
   - 仅在用户批准后执行
   - 使用系统的命令执行功能执行命令
   - 向用户显示命令执行结果

4. **反馈收集**：
   - 等待用户对完成结果的反馈
   - 处理反馈并返回给 AI
   - 基于用户输入支持持续优化

5. **任务完成和延续**：
   - 在系统中标记任务已完成
   - 捕获已完成任务的遥测数据
   - 对于子任务，提供完成子任务并恢复父任务的选项
   - 通过反馈机制支持持续对话
   - 支持复杂嵌套工作流同时保持上下文

6. **实现集成**：
   - 工具结果通过 `parse-assistant-message.ts` 中的系统解析机制解析
   - 该工具是"ALWAYS_AVAILABLE_TOOLS"常量的一部分，在所有模式中均可使用

---

## 结果格式化指南

结果消息应遵循以下指南：

- 清晰说明完成的内容
- 简洁但完整
- 专注于为用户提供的价值
- 避免不必要的客套话或填充内容
- 保持专业、直接的语调
- 以易于浏览和理解的方式呈现信息
- 承认用户可能提供反馈以进行进一步优化

注意：系统通过 `removeClosingTag` 函数自动从结果文本中移除 XML 结束标签。

---

## 命令选择指南

包含命令时，请遵循以下指南：

- 选择能直观展示结果的命令
- 优先选择展示用户创建或修改内容的命令
- 示例包括：
  * `open index.html` 展示创建的网站
  * `npm start` 启动开发服务器
  * `python app.py` 运行创建的应用程序
- 避免仅打印文本的命令（如 `echo` 或 `cat`）
- 记住命令需要用户批准才能执行
- 确保命令与用户的操作系统兼容

---

## 反馈和 UI 表示

`attempt_completion` 工具有独特的反馈机制：

- 结果以特殊的"completion_result" UI 格式显示，区别于常规消息
- 系统在展示结果后等待用户反馈
- 反馈被处理并返回给 Roo 以进行进一步优化
- 这创建了一个迭代改进循环，而非结束对话
- UI 包含用于提供反馈的特殊元素
- 结果作为对话流程中的明确检查点

在子任务中使用时：
- 系统提供完成子任务并恢复父任务的选项
- 如获批准，子任务以摘要完成
- 父任务在已完成子任务的上下文中恢复
- 这支持复杂嵌套工作流同时保持上下文

---

## 使用示例

- 创建网站时，Roo 展示解决方案并使用 `open index.html` 显示结果。用户提供建议，Roo 优化设计。
- 实现功能时，Roo 总结更改及其影响。用户请求额外测试覆盖，Roo 继续任务。
- 修复 bug 时，Roo 解释修复内容及解决方案如何解决根本原因。用户确认修复有效。
- 设置开发环境时，Roo 确认所有组件已安装。用户请求额外配置，Roo 继续。
- 创建数据处理脚本时，Roo 总结功能。用户建议性能优化，Roo 优化代码。

---

## 使用示例

仅使用结果摘要完成任务：
```
<attempt_completion>
<result>
我已更新导航栏的 CSS 以匹配设计稿。更改包括：
1. 更新配色方案以使用新品牌色
2. 为移动设备添加响应式行为
3. 修复下拉菜单的对齐问题
</result>
</attempt_completion>
```

使用结果和演示命令完成任务：
```
<attempt_completion>
<result>
我已创建一个简单的 React 应用，具有以下功能：
1. 带有请求的英雄区域的响应式着陆页
2. 带验证的联系表单
3. 所有三个请求页面之间的导航
4. 匹配提供设计稿的样式
</result>
<command>npm start</command>
</attempt_completion>
```

使用执行完成 Python 脚本任务：
```
<attempt_completion>
<result>
我已创建一个数据处理脚本，功能包括：
1. 从 data 目录读取 CSV 文件
2. 按请求清理和标准化数据
3. 以 JSON 格式生成摘要统计
4. 将处理后的数据输出到 output 目录
</result>
<command>python process_data.py</command>
</attempt_completion>
```